MVC : Model View Controller

Typical servlet : HTML code embedded into Java code, Typical JSP : Java code embedded into HTML code

M odel : data
V iew : data
C ontroller : manages application flow, makes a call to a some sort of service producing model and then passes on the model to the view.

Controller -> (Passes Model) -> to View

Inversion of Control or Dependency injection

Browser (request) -> Front controller -> Handler Mapping (Scan the URL; tells the exact address of the component which can generate data for the web request requested for -> Front
Controller -> Data generator (prepares data, creates Java object to hold the data - may take help of other Java classes if it is required to do the job) (Java Object which holding data + 
Name of the component which is going to retrieve data from the Java Object + mixing with HTML to generate actual response -> Front Handler -> View resolver (tells the address of the view maker)
-> Front Controller (Java Object) -> Final response builder (creates final response with HTML and Java Objects) -> Browser

Client -> Dispatcher Servlet -> Handler Mapping -> Dispatcher Servlet -> Controller -> Dispatcher Servlet -> View resolver -> Dispatcher Servlet -> JSP/ Velocity/ Freemaker -> Dispatcher Servlet
-> Client

Java object with data : model

/ : Dispatcher Servlet : Front handler
Handler mapping resolves the url to actual class which can serve client

There are many HandlerMapping classes

Class not found exception for DispatcherServlet:
	need to add the "Maven Dependency" in the Deployment Assembly
	    right click on project and choose properties.
	    click on Deployment Assembly.
	    click add
	    click on "Java Build Path Entries"
	    select Maven Dependencies"
	    click Finish.
		Rebuild and deploy again
		
Annotation:
no need to extend
no need to specify in dispatcher servlet
If need to use annotation, need to add that package or class for component scan

front controller reads spring-dispatcher-servlet to process further. When "context:component-scan" is used, it will load all the classes in the base package.
@RequestMapping is used to detect the method to execute for a url. matching url against RequestMapping values

Methods to serve request : request handler methods
Controller class having more than one request handler methods : Multi action controller class

Type http://localhost:8090/FirstSpringMVCProject/wrfer
No resources are available to process this URL

Relative url can be achieved by having @RequestMapping annotation in class level

ABCD as mobile : auto binding fails because can't convert ABCD to long
Handle: resend the form with BindingResult

Need to bind except one value: @InitBinder and WebDataBinder

By default date format : yyyy/mm/dd: to change it to yyyy****mm****dd - need to change property editors : CustomDateEditor with registerCustomEditor
Other examples for Property editors : FileEditor, ClassEditor, CustomMemberEditor
SpringMVC uses property editor classes in order to perform type conversion while performing data binding.
Customize data binding for a type: by editing property editor for that type

Custom property editor classes can be written other than built-in property editor classes
Specific requirement: need to write custom property class:
Eg: Mr/Miss/Mrs in the name of student is needed and default value is Miss

Form validation eg:
2 < Hobby char count < 30 : By @Size annotation
need to activate form validation by @Valid annotation

to use form validation, need to use a third party implementation for JSR 303, JSR 349 : Eg: Hibernate validator library, Apache bean validator library

JSR (Java Specification Request) standard by JCP (Java Community Process)

******************************************************************************************************************************************

javax.servlet.ServletException: Error instantiating servlet class org.springframework.web.servlet.DispatcherServlet
	org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496)
	org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)
	org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:620)
	org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:502)
	org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1132)
	org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:684)
	org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1539)
	org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1495)
	java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	java.lang.Thread.run(Unknown Source)


root cause
java.lang.ClassNotFoundException: org.springframework.web.servlet.DispatcherServlet
	org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1352)
	org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1180)
	org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496)
	org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)
	org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:620)
	org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:502)
	org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1132)
	org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:684)
	org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1539)
	org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1495)
	java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	java.lang.Thread.run(Unknown Source)

-----------------------------------------------------------------------------------------------------------------------------------------------
Solution: Project right click -> properties -> Deployment Assembly -> Add -> Java Build Path Entries -> Next -> Maven Dependencies -> Finish
-> Apply -> OK
************************************************************************************************************************************************
Key for message for a validation: [Validation annotation name].[Object reference name].[Field name]
If not found that key it will search for : [Validation annotation name].[Field name]
If not found that key it will search for : [Validation annotation name].[Field type] [Eg: (Size.java.lang.String)]
If not found that key it will search for : Size (default message by spring framework)

************************************************************************************************************************************************
place holder for validation messages from property files:
{0} : name of the field
{1}, {2}, ... : arguments passed to the annotation
Spring MVC uses argument order alphabetically:
==> max - {1}, min - {2}

<property name="cacheSeconds" value="1" /> : Tell Spring mvc to load changes in property files for every second of runtime: not to recommend in production: only in Development
unnecessary performance issue

